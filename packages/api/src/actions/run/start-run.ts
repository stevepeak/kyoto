import type { DB } from '@app/db/types'
import type { Insertable, Selectable } from 'kysely'
import type { Kysely } from 'kysely'
import { Octokit } from '@octokit/rest'
import { createAppAuth } from '@octokit/auth-app'

import type { RunStory } from '@app/db/src/column-types'
import { analyzeRepository } from '../repo/analyze'

interface StartRunParams {
  db: Kysely<DB>
  orgSlug: string
  repoName: string
  branchName?: string
  appId: number
  privateKey: string
  openRouterApiKey: string
}

export interface StartRunResult {
  success: boolean
  run?: Selectable<DB['runs']>
  error?: string
}

/**
 * Starts a new run by:
 * 1. Analyzing the repository to pull/refresh stories
 * 2. Getting all stories for the repo and branch
 * 3. Getting commit SHA and message from GitHub
 * 4. Creating a run with all stories marked as 'pass'
 */
export async function startRun(
  params: StartRunParams,
): Promise<StartRunResult> {
  const {
    db,
    orgSlug,
    repoName,
    branchName,
    appId,
    privateKey,
    openRouterApiKey,
  } = params

  try {
    // Step 1: Look up owner and repo
    const owner = await db
      .selectFrom('owners')
      .selectAll()
      .where('login', '=', orgSlug)
      .executeTakeFirst()

    if (!owner) {
      return {
        success: false,
        error: `Owner with slug ${orgSlug} not found`,
      }
    }

    const repo = await db
      .selectFrom('repos')
      .selectAll()
      .where('ownerId', '=', owner.id)
      .where('name', '=', repoName)
      .executeTakeFirst()

    if (!repo) {
      return {
        success: false,
        error: `Repository ${repoName} not found for owner ${orgSlug}`,
      }
    }

    // Step 2: Determine branch to use (default to repo.defaultBranch)
    const targetBranch = branchName || repo.defaultBranch
    if (!targetBranch) {
      return {
        success: false,
        error: `No branch specified and repository has no default branch configured`,
      }
    }

    if (!owner.installationId) {
      return {
        success: false,
        error: `Owner ${orgSlug} has no GitHub App installation configured`,
      }
    }

    const installationId = Number(owner.installationId)

    // Step 3: Analyze repository to pull/refresh stories
    const analysisResult = await analyzeRepository({
      db,
      repoId: repo.id,
      appId,
      privateKey,
      openRouterApiKey,
    })

    if (!analysisResult.success) {
      return {
        success: false,
        error: analysisResult.error || 'Failed to analyze repository',
      }
    }

    // Step 4: Get all stories for this repo and branch
    const stories = await db
      .selectFrom('stories')
      .selectAll()
      .where('repoId', '=', repo.id)
      .where('branchName', '=', targetBranch)
      .execute()

    if (stories.length === 0) {
      return {
        success: false,
        error: 'No stories found for this repository and branch',
      }
    }

    // Step 5: Get commit SHA and message from GitHub
    const octokit = new Octokit({
      authStrategy: createAppAuth,
      auth: { appId, privateKey, installationId },
    })

    const branchRef = await octokit.git.getRef({
      owner: orgSlug,
      repo: repoName,
      ref: `heads/${targetBranch}`,
    })
    const commitSha = branchRef.data.object.sha

    // Get commit message
    const commit = await octokit.git.getCommit({
      owner: orgSlug,
      repo: repoName,
      commit_sha: commitSha,
    })
    const commitMessage = commit.data.message || null

    // Step 6: Create run with all stories marked as 'pass'
    const runStories: RunStory[] = stories.map((story) => ({
      storyId: story.id,
      status: 'pass',
    }))

    const runToInsert: Insertable<DB['runs']> = {
      repoId: repo.id,
      commitSha,
      branchName: targetBranch,
      commitMessage,
      status: 'pass',
      stories: runStories,
    }

    // Note: The run number will be auto-generated by the database trigger
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    const insertedRun = await (db as any)
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .insertInto('runs')
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .values(runToInsert)
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .returningAll()
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .executeTakeFirstOrThrow()

    return {
      success: true,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      run: insertedRun as Selectable<DB['runs']>,
    }
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error occurred'
    return {
      success: false,
      error: errorMessage,
    }
  }
}
