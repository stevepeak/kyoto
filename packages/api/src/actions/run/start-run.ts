import type { DB } from '@app/db/types'
import type { Insertable, Selectable } from 'kysely'
import type { Kysely } from 'kysely'
import { Octokit } from '@octokit/rest'
import { createAppAuth } from '@octokit/auth-app'

import { configure, tasks } from '@trigger.dev/sdk'

interface StartRunParams {
  db: Kysely<DB>
  orgSlug: string
  repoName: string
  branchName?: string
  appId: number
  privateKey: string
  openRouterApiKey: string
  databaseUrl: string
  triggerSecretKey: string
}

export interface StartRunResult {
  success: boolean
  run?: Selectable<DB['runs']>
  error?: string
}

/**
 * Starts a new run by:
 * 1. Looking up owner and repo
 * 2. Getting commit SHA and message from GitHub
 * 3. Creating a run with 'running' status
 * 4. Triggering the workflow to analyze repo, test stories, and update GitHub status
 */
export async function startRun(
  params: StartRunParams,
): Promise<StartRunResult> {
  const {
    db,
    orgSlug,
    repoName,
    branchName,
    appId,
    privateKey,
    openRouterApiKey,
    databaseUrl,
    triggerSecretKey,
  } = params

  let runId: string | null = null

  console.log('triggerSecretKey', triggerSecretKey)
  configure({
    secretKey: triggerSecretKey,
  })

  try {
    // Step 1: Look up owner and repo
    const owner = await db
      .selectFrom('owners')
      .selectAll()
      .where('login', '=', orgSlug)
      .executeTakeFirst()

    if (!owner) {
      return {
        success: false,
        error: `Owner with slug ${orgSlug} not found`,
      }
    }

    const repo = await db
      .selectFrom('repos')
      .selectAll()
      .where('ownerId', '=', owner.id)
      .where('name', '=', repoName)
      .executeTakeFirst()

    if (!repo) {
      return {
        success: false,
        error: `Repository ${repoName} not found for owner ${orgSlug}`,
      }
    }

    // Step 2: Determine branch to use (default to repo.defaultBranch)
    const targetBranch = branchName || repo.defaultBranch
    if (!targetBranch) {
      return {
        success: false,
        error: `No branch specified and repository has no default branch configured`,
      }
    }

    if (!owner.installationId) {
      return {
        success: false,
        error: `Owner ${orgSlug} has no GitHub App installation configured`,
      }
    }

    const installationId = Number(owner.installationId)

    // Step 3: Get commit SHA and message from GitHub (before creating run)
    const octokit = new Octokit({
      authStrategy: createAppAuth,
      auth: { appId, privateKey, installationId },
    })

    const branchRef = await octokit.git.getRef({
      owner: orgSlug,
      repo: repoName,
      ref: `heads/${targetBranch}`,
    })
    const commitSha = branchRef.data.object.sha

    // Get commit message
    const commit = await octokit.git.getCommit({
      owner: orgSlug,
      repo: repoName,
      commit_sha: commitSha,
    })
    const commitMessage = commit.data.message || null

    // Step 4: Create run with 'running' status (insert early)
    // Note: number is auto-generated by database trigger, so we omit it
    const runToInsert: Omit<Insertable<DB['runs']>, 'number'> = {
      repoId: repo.id,
      commitSha,
      branchName: targetBranch,
      commitMessage,
      status: 'running',
      stories: [],
    }

    // Note: The run number will be auto-generated by the database trigger
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    const insertedRun = (await (db as any)
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .insertInto('runs')
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .values(runToInsert)
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .returningAll()
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      .executeTakeFirstOrThrow()) as Selectable<DB['runs']>

    runId = insertedRun.id

    // Step 5: Trigger the workflow to handle the rest asynchronously
    // The workflow will:
    // - Analyze repository
    // - Test all stories
    // - Update run with results
    // - Update GitHub status
    const workflowPayload = {
      runId,
      orgSlug,
      repoName,
      branchName: targetBranch,
      repoId: repo.id,
      commitSha,
      commitMessage: commitMessage ?? null,
      installationId,
      appId,
      privateKey,
      openRouterApiKey,
      databaseUrl,
    } as const
    // Trigger the workflow using Trigger.dev client API
    await tasks.trigger('execute-run', workflowPayload)

    // Return the run immediately (workflow will update it asynchronously)
    return {
      success: true,

      run: insertedRun,
    }
  } catch (error) {
    // Update run status to 'fail' on any error
    if (runId) {
      try {
        await db
          .updateTable('runs')
          .set({ status: 'fail' })
          .where('id', '=', runId)
          .execute()
      } catch (updateError) {
        // Log but don't throw - we want to return the original error
        console.error('Failed to update run status on error:', updateError)
      }
    }

    const errorMessage =
      error instanceof Error ? error.message : 'Unknown error occurred'
    return {
      success: false,
      error: errorMessage,
    }
  }
}
